記述したコードの内容に対して、改行してしまうと新たなコードを読み込んでしまうので１行で書くことが必須！！！！！
以下のような書き方はNGになる。spritメソッドが重要！
m = gets.to_i
n = gets.to_i
--------------------------------------------------------------

配列からハッシュにする ＊を使用する
ary = [1, "ねずみ", 2, "うし", 3, "とら"]
h = Hash[*ary]
=>{1=>"ねずみ", 2=>"うし", 3=>"とら"}

ary = [["suzuki", 87], ["itou", 76], ["yamada", 69]]
h = Hash[*ary.flatten]  flattenメソッド

keyAry = ["suzuki", "itou", "yamada"]
keyValue = [87, 76, 69]
ary = [keyAry,keyValue].transpose
h = Hash[*ary.flatten]  flattenメソッド
--------------------------------------------------------------

.merge  ハッシュ同士をつなげる
hash1 = {"経済学" => 80, "財政学" => 70, "会計学" => 60}
hash2 = {"経営学" => 75, "会社法" => 65}
hash3 = hash1.merge(hash2)
p hash3
#=> {"経済学"=>80, "財政学"=>70, "会計学"=>60, "経営学"=>75, "会社法"=>65}
-------------------------------------------------------------

・to_i #数字の場合
---------------------------------------------------------------

・to_s #数字などを文字列に変換
---------------------------------------------------------------

・to_h #ハッシュに置き換える
---------------------------------------------------------------

.to_a #ハッシュから配列に変換する この時注意するのは変換するキーとバリューが1つでも二次元配列になる点です。
human = {name: "pikawaka", age: e25}
human.to_a
=> [[:name, "pikawaka"], [:age, 25]]
---------------------------------------------------------------

.n,*m = gets.split(" ").map &to_i
# *を入れることで、m以降の変数は、m配列入れられる。
---------------------------------------------------------------

配列.sort[-2] #配列の中で２番目に大きい数字を取ることができる
---------------------------------------------------------------

.reverse #「reverse」メソッドは配列に格納されている要素を逆の順番で格納した新しい配列を返します。
ary = [1, 2, 3, 4, 5]
newary = ary.reverse 
[5, 4, 3, 2, 1]
----------------------------------------------------------------

.scan
#scanは、対象の要素から引数で指定した文字列を数え、配列として返すメソッドです。
#scanメソッドの詳細は公式リファレンスを確認しましょう。
"foobarbazfoobarbaz".scan("ba")
=> ["ba", "ba", "ba", "ba"]
-----------------------------------------------------------------

.round 
#「round」メソッドは四捨五入して整数に丸めます。「1.1」は「1」へ「1.7」は「2」へ「-1.2」は「-1」へ
#「-1.7」は「-2」へ変換されます。中央値の「0.5」は「1」へ「-0.5」は「-1」へ変換されます。
---------------------------------------------------------------

・strip 
#文字列の先頭と末尾にある空白を除去した文字列を生成して返してくれるStringクラスのメソッドです。
#空白だけでなく「タブ」や「改行コード」「改頁コード」「垂直タブ」なども除去してくれます。ただ残念なことに「全角スペース」は通常の文字と認識されてしまい、除去してくれません。
#文字列の先頭や末尾にある全角スペースを除去したい場合はgsubメソッドなどで半角スペースに変換してからstripメソッドを使用すれば除去できます。
#メソッド名の最後にビックリマーク(!)のついた破壊的メソッドを使用すると、もとの文字列が上書き更新されますので注意が必要です。
---------------------------------------------------------------

・slice #文字列を分けることができる slice!で破壊的メソッド
str = 'Super Multiple Vitamin 12'
# 範囲で指定
str.slice(6..10) #=> "Multi"
 
# 正規表現で指定
str.slice(/[0-9]+/) #=> "12"


str.slice(0,2) #"Su" 0が増えていくことにより、そこから２個目の値をとる



---------------------------------------------------------------

.delete! #指定した文字を文字列から削除する
str = "abcdaaefaagh"
str.delete("a")=> "bcdefgh"
str.delete!("a")=> "bcdefgh"
---------------------------------------------------------------

.index
#indexメソッドは、文字列や配列の中に指定した文字列が含まれていた場合、その文字列の開始位置を整数の値で返します。
#indexメソッドの詳細は公式リファレンスを確認しましょう。
str.index(検索したい文字列, [検索を開始する位置])
---------------------------------------------------------------

.uniq
# 「uniq」メソッドは配列に含まれる要素の中で同じ要素があった場合に重複している要素を取り除きいた新しい配列を返します。
# 要素が等しいかどうかはObjectクラスの「eql?」メソッドが内部的に使われて比較されます。
# 具体的には次のように記述します。
ary = [1, 2, 5, 2, 3, 5]
newary = ary.uniq
この場合、配列の要素の中には「2」と「5」が重複していますので、これらを取り除いた次の新しい配列を取得します。
[1, 2, 5, 3]
ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

・split("") #配列の中身をどこで分けるかを決める
m,p,q = gets.split(" ").map(&:to_i) #文字列に対して整数変換
= gets.split(“ “).map{|n| n.to_i} #文字列に対して整数変換
---------------------------------------------------------------

・downcase #全ての大文字を対応する小文字に破壊的に置き換えます。
'BIG'.downcase => "big"
---------------------------------------------------------------

・upcase #全てを大文字に変換
'small'.upcase => "SMALL"
---------------------------------------------------------------

.swapcase #大文字と小文字を変換
'BIG small'.swapcase => "big SMALL"
---------------------------------------------------------------

.capitalize #先頭の文字だけ大文字
'aaa'.capitalize => "Aaa"
---------------------------------------------------------------

・length size #文字列の値の数 もしくは 文字列の文字の数
---------------------------------------------------------------

・count #配列の要素数を条件つきで取得する
array = ["red","blue","yellow","red","green"]
array.count("red") #redの数を数えるため、2となる

array = [1,2,2,2,3,3,4,5,]
array.count{ |num| num % 2 == 0} #要素を２で割った余りが０の数を数える

array.count{ |num| !num.nil? } #!マークをつけると否定になる
---------------------------------------------------------------

・each_with_index #eachループで回しつつ、それぞれのデータに番号を振りたい
fruit = ["りんご", "みかん", "いちご"]
fruit.each_with_index do |item, i|
 "#{i}番目のフルーツは、#{item}"です。
end

fruit.each.with_index(10) do |item, i| #10から番号をつけたいという場合
  "#{i}番目のフルーツは、#{item}"です。
end
---------------------------------------------------------------

.pop #末尾の要素を削除
array.pop(2) #末尾から２つの要素を削除
---------------------------------------------------------------

.shift #配列の先頭の要素を削除 popの逆
---------------------------------------------------------------

.push #配列の末尾に要素を追加するメソッド
array = [1, 2, 3, 4]
array.push(5) #[1, 2, 3, 4, 5]5が追加される
---------------------------------------------------------------

.insert #配列に要素を挿入する場合
配列.insert(挿入位置, 挿入する要素)
a = [1, 2, 3]
a.insert(2, 4)
print a # [1, 2, 4, 3]

a = [1, 2, 3]  #複数要素を同時に挿入する場合
a.insert(2, 4, 5)
print a # [1, 2, 4, 5, 3]
----------------------------------------------------------------

.unshift #要素を先頭に挿入する場合
配列.unshift(挿入する要素)
a = [1, 2, 3]
a.unshift(4)
print a # [4, 1, 2, 3]

a = [1, 2, 3]  #複数要素を同時に先頭に挿入する場合
a.unshift(4, 5)
print a # [4, 5, 1, 2, 3]
----------------------------------------------------------------

.join #配列を連結する際に使用するメソッドが「joinメソッド」です。
array = ['ruby', 'python']
p array.join #"rubypython"

array = ['ruby', 'python','java']
p array.join(',') #"ruby,python,java"

array = [['ruby','rails'],['python','django']]
p array.join(' ') #"ruby rails python django"
--------------------------------------------------------------

.sort #配列に格納されている要素を一定の規則でソートした新しい配列を返します
ary = [4, 2, 5, 1, 3]
newary = ary.sort #[1, 2, 3, 4, 5]
---------------------------------------------------------------

.next：次の整数を返す
.even?：偶数かどうかをtrue or falseで判定
.odd?：奇数かどうかをtrue or falseで判定
puts 1.next  # 2
puts 1.even? # false
puts 1.odd?  # true
---------------------------------------------------------------

//Timeclass
time = Time.now #現在時刻の取得
puts time #現在時刻を出力 # 2018-05-28 06:40:30 +0000
puts time.getlocal("+09:00") #イギリスを基準とした協定世界時の9時間後のつまり、日本時刻を出力 # 2018-05-28 15:40:30 +0900
puts time.year #現在時刻の年だけ出力 # 2018
puts time.month #現在時刻の月だけ出力 # 5
puts time.day #現在時刻の 日だけ出力 # 28
puts time.monday? #現在時刻の月だけ出力 # true
---------------------------------------------------------------

.transpose #配列に要素として他の配列が格納されている場合に、配列を行列と見なし行と列を入れ替える
ary = [["suzuki", 89], ["yamada", 76], ["itou", 69]]
p ary #[["suzuki", 89], ["yamada", 76], ["itou", 69]]

newary = ary.transpose
p newary #[["suzuki","yamada","itou"],["89,76,69]]
---------------------------------------------------------------

.chars #文字列に対してcharsメソッドを使用すると1文字ずつ分割してくれてます。
p "hello".chars
["h", "e", "l", "l", "o"]
#文字列が数字だと、他のメソッドと組み合わせることで「各位を足しあわせた合計値」なんて操作もできるようになります。
list = "12345".chars.map(&:to_i)
p list
p list.sum
[1, 2, 3, 4, 5]
15
----------------------------------------------------------------

.zip #配列同士をつなげる
p [1,2,3].zip([4,5,6], [7,8,9])
# => [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
p [1,2].zip([:a,:b,:c], [:A,:B,:C,:D])
# => [[1, :a, :A], [2, :b, :B]]
p [1,2,3,4,5].zip([:a,:b,:c], [:A,:B,:C,:D])
# => [[1, :a, :A], [2, :b, :B],
#     [3, :c, :C], [4, nil, :D], [5, nil, nil]]
p [1,2,3].zip([4,5,6], [7,8,9]) { |ary| p ary }
# => [1, 4, 7]
#    [2, 5, 8]
#    [3, 6, 9]
#    nil
----------------------------------------------------------------

.ljust #指定した長さの文字列にselfを左寄せした文字列を返す
'ab'.ljust(1) #=> "ab"
'ab'.ljust(4) #=> "ab  "
# 埋める文字を指定することも可能
'ab'.ljust(4, '*') #=> "ab**"

.rjust #指定した長さの文字列にselfを左寄せした文字列を返す
'ab'.rjust(1) #=> "ab"
'ab'.rjust(4) #=> "  ab"

.center #指定した長さの文字列にselfを中央寄せした文字列を返す
'ab'.center(4) #=> " ab "
----------------------------------------------------------------

.chop #文字種に関わらず末尾の1文字を取り除く
"client\n".chop  #=> "client"
-----------------------------------------------------------------

.squeeze 
#同じ文字列が連続した場合に１つにまとめる
'Greeeen'.squeeze #=>Gren
# まとめる対象を指定することも可能
'aabbaacc'.squeeze('ab') #=> "abacc"
------------------------------------------------------------------

.sub #最初にマッチした文字列の置換
.gsub #マッチした文字列すべてを置換
'静岡県 埼玉県'.sub('県', 'X') #=> "静岡X 埼玉県"
'静岡県 埼玉県'.gsub('県', 'X') #=> "静岡X 埼玉X"
# ブロックを渡すことも可能
'09-123-9'.gsub(/[0-9]/) {|str| str.to_i.succ} #=> '110-234-10"
------------------------------------------------------------------

.each_char
文字ごとの繰り返し
'たのし'.each_char {|c| print "#{c}ー"} #=> たーのーしー

.each_line
行ごとの繰り返し
"われわれは\nかしこいので\nかしこいので".each_line {|line| puts line}
#=>
われわれは
かしこいので
かしこいので
-------------------------------------------------------------------

.for #繰り返し
for 変数 in 0..4
  p 変数
end
-------------------------------------------------------------------

.breke #繰り返しを限定して終了する 下記では３で終了
for 変数 in 0..4
  if 変数 = 3
    breke
  end
  p 変数
end
-------------------------------------------------------------------

.next #スキップさせる #0,1,2,4
for 変数 in 0..4
  if 変数 = 3
    next
  end
  p 変数
end
---------------------------------------------------------------------

.for #ネストさせる １週目で３回繰り返し,２週目で３回繰り返す
for i(変数) in 0..2
  for j(変数) in 0..2
    p i.to_s + "-" + j.to_s
  end    
end
----------------------------------------------------------------------

.redo #ある条件を満たしたら、与えられたオブジェクト（ルール）を無視できるというものです。
for i in 1..5 do
  if i == 4
    i = 5
    redo
  end
  p i
end
=> 1,2,3,5,5 ４の代わりに５が来る
------------------------------------------------------------------

.while #for文は指定した要素分繰り返し処理を行うのに対して、while文は条件式がfalseになるまで処理を繰り返し行います。
num = 0
while num <= 12 do  12まで繰り返し
  p num
  num += 3
end
=> 0,3,6,9,12 
------------------------------------------------------------------

.until #whileが条件がtrueの間繰り返すのに対して、こちらはfalseの間繰り返すメソッドになります。
num = 16
until num <=12 do
  p num
  num -=1
end
=> 16,15,14,13
--------------------------------------------------------------------

.each_cons #要素を重複ありで n 要素ずつに区切り、ブロックに渡して繰り返します。
(1..10).each_cons(3){|v| p v }
# => [1, 2, 3]
#    [2, 3, 4]
#    [3, 4, 5]
#    [4, 5, 6]
#    [5, 6, 7]
#    [6, 7, 8]
#    [7, 8, 9]
#    [8, 9, 10]

.each_slice #n 要素ずつブロックに渡して繰り返します。要素数が n で割り切れないときは、最後の回だけ要素数が減ります。
(1..10).each_slice(3) {|a| p a}
    # => [1, 2, 3]
    #    [4, 5, 6]
    #    [7, 8, 9]
    #    [10]


.each_with_object #与えられた任意のオブジェクトと要素をブロックに渡し繰り返し、最初に与えられたオブジェクトを返します。
evens = (1..10).each_with_object([]) {|i, a| a << i*2 }
# => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

.each_with_index #要素とそのインデックスをブロックに渡して繰り返します
[5, 10, 15].each_with_index do |n, idx|
  p [n, idx]
end
# => [5, 0]
#    [10, 1]
#    [15, 2]

-------------------------------------------------------------------------

Rubyにはelsifとelse ifがある
先ほど説明したように、Rubyのif構文では、
「ぶら下がりelse問題」があるので、複数の条件を使ってif構文を使う場合は、elsifを使用します。
(0..4).each do |time|
  o = 0
  x = 0
  
  index.each do |i|
      if i[time] == "O"
          o += 1
      elsif i[time] == "X"   if文が２つある場合はelsifを使用する
          x += 1
      end
  end
  
  if o == 5
      result = "O"
      break
  elsif x == 5                 if文が２つある場合はelsifを使用する
      result = "X"
      break
  end
end
-------------------------------------------------------------------------

# 各要素を順番にブロックに渡して評価し、
# その評価結果を <=> で比較して、最小であった値に対応する元の要素、もしくは最小の n 要素が昇順で入った配列を返します。
比較対象に近い値を持ってくる
min_by
atai.min_by{|c| (c-n).abs}

-------------------------------------------------------------------------

